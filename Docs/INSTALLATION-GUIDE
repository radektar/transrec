# Olympus Transcriber - Installation Guide (Markdown)

## ğŸ“Œ Overview

Kompletny installation guide dla **Olympus Transcriber** - systemu automatycznie transkrybujÄ…cego pliki audio z rekordera Olympus LS-P1.

**Czas konfiguracji:** ~30 minut  
**Technologia:** Python 3, MacFSEvents, MacWhisper  
**Åšrodowisko:** macOS (Silicon lub Intel)

**Plik na podstawie:** `docs/olympus-installation-guide.pdf`

---

## CZÄ˜ÅšÄ† 1: Przygotowanie Projektu (5 minut)

### 1.1 UtwÃ³rz folder projektu

OtwÃ³rz Terminal i uruchom:

```bash
mkdir -p ~/Projects/olympus-transcriber
cd ~/Projects/olympus-transcriber
```

### 1.2 Inicjalizuj Git (optional ale rekomendowany)

```bash
git init
git config user.name "Your Name"
git config user.email "your.email@example.com"
```

### 1.3 OtwÃ³rz w Cursor

**Opcja 1 - CLI:**
```bash
cursor ~/Projects/olympus-transcriber
```

**Opcja 2 - GUI:**
- OtwÃ³rz Cursor
- File â†’ Open â†’ ~/Projects/olympus-transcriber

### 1.4 UtwÃ³rz strukturÄ™ folderÃ³w

W Cursor (Left Sidebar):

1. **Prawy klik** na root folder
2. **New Folder** â†’ `src`
3. **New Folder** â†’ `tests`
4. **New Folder** â†’ `docs`
5. **New Folder** â†’ `.cursor`
   - W `.cursor` â†’ **New Folder** â†’ `rules`
6. **New Folder** â†’ `.vscode`

Finalna struktura:
```
olympus-transcriber/
â”œâ”€â”€ .cursor/
â”‚   â””â”€â”€ rules/
â”œâ”€â”€ .vscode/
â”œâ”€â”€ docs/
â”œâ”€â”€ src/
â”œâ”€â”€ tests/
â”œâ”€â”€ venv/ (utworzy siÄ™ w nastÄ™pnym kroku)
â””â”€â”€ ...config files...
```

---

## CZÄ˜ÅšÄ† 2: Virtual Environment (5 minut)

### 2.1 OtwÃ³rz Terminal w Cursor

Keyboard: **Ctrl + `` (backtick)**  
Lub: **Terminal** â†’ **New Terminal**

### 2.2 UtwÃ³rz Virtual Environment

```bash
python3 -m venv venv
```

### 2.3 Aktywuj Virtual Environment

```bash
source venv/bin/activate
```

**âœ“ Powinno pokazaÄ‡:**
```
(venv) user@macbook olympus-transcriber %
```

### 2.4 Zainstaluj pip tools

```bash
pip install --upgrade pip setuptools wheel
```

---

## CZÄ˜ÅšÄ† 3: Pliki Konfiguracyjne (5 minut)

### 3.1 UtwÃ³rz `.gitignore`

W Cursor: **New File** â†’ `.gitignore`

Wklej zawartoÅ›Ä‡:

```gitignore
# Virtual Environment
venv/
env/
.venv

# Python
__pycache__/
*.py[cod]
*$py.class
*.so
.Python
build/
dist/
*.egg-info/

# IDE
.vscode/
.cursor/
.DS_Store
*.swp

# Logs
*.log
/tmp/

# Project specific
.olympus_transcriber_state.json
```

### 3.2 UtwÃ³rz `requirements.txt`

**New File** â†’ `requirements.txt`

```
MacFSEvents>=0.1.1
pyobjc-framework-Cocoa>=10.0
pyobjc-framework-FSEvents>=10.0
python-dotenv>=1.0.0
click>=8.1.0
```

### 3.3 UtwÃ³rz `requirements-dev.txt`

**New File** â†’ `requirements-dev.txt`

```
pytest>=7.0.0
pytest-cov>=4.0.0
pytest-mock>=3.10.0
black>=23.0.0
flake8>=6.0.0
mypy>=1.0.0
isort>=5.12.0
```

### 3.4 Zainstaluj Dependencies

W Terminal (s aktywnym venv):

```bash
pip install -r requirements.txt
pip install -r requirements-dev.txt
```

**âœ“ Powinna byÄ‡ lista zainstalowanych pakietÃ³w:**
```
Successfully installed MacFSEvents-... pyobjc-framework-... 
```

---

## CZÄ˜ÅšÄ† 4: Tworzenie Source Code (10 minut)

### 4.1 UtwÃ³rz `src/__init__.py`

**New File** â†’ `src/__init__.py`

```python
"""Olympus Transcriber - Automatic transcription system."""

__version__ = "0.1.0"
```

### 4.2 UtwÃ³rz `src/config.py`

**New File** â†’ `src/config.py`

```python
"""Configuration for Olympus Transcriber."""

from pathlib import Path
from dataclasses import dataclass


@dataclass
class Config:
    """Application configuration."""
    
    # Recorder detection
    RECORDER_NAMES = ["LS-P1", "OLYMPUS", "RECORDER"]
    
    # Output directory
    TRANSCRIBE_DIR = Path.home() / "Documents" / "Transcriptions"
    
    # State tracking
    STATE_FILE = Path.home() / ".olympus_transcriber_state.json"
    
    # Logging
    LOG_DIR = Path.home() / "Library" / "Logs"
    LOG_FILE = LOG_DIR / "olympus_transcriber.log"
    
    # MacWhisper binary paths (try in order)
    MACWHISPER_PATHS = [
        "/Applications/MacWhisper.app/Contents/MacOS/MacWhisper",
        "/usr/local/bin/macwhisper",
        "/opt/homebrew/bin/macwhisper",  # Mac with Apple Silicon
    ]
    
    # Timeouts (seconds)
    TRANSCRIPTION_TIMEOUT = 1800  # 30 minutes
    PERIODIC_CHECK_INTERVAL = 30   # Check every 30 seconds
    MOUNT_MONITOR_DELAY = 1        # Wait 1 second after mount


# Global config instance
config = Config()
```

### 4.3 UtwÃ³rz `src/logger.py`

**New File** â†’ `src/logger.py`

```python
"""Centralized logging setup."""

import logging
from pathlib import Path

from src.config import config


def setup_logger(name: str = "olympus_transcriber") -> logging.Logger:
    """
    Setup centralized logging with file and console handlers.
    
    Args:
        name: Logger name
        
    Returns:
        Configured logger instance
    """
    # Create log directory
    config.LOG_DIR.mkdir(parents=True, exist_ok=True)
    
    # Get logger
    logger = logging.getLogger(name)
    logger.setLevel(logging.DEBUG)
    
    # Clear existing handlers
    logger.handlers.clear()
    
    # File handler (INFO level)
    fh = logging.FileHandler(config.LOG_FILE)
    fh.setLevel(logging.INFO)
    
    # Console handler (DEBUG level, for development)
    ch = logging.StreamHandler()
    ch.setLevel(logging.DEBUG)
    
    # Formatter
    formatter = logging.Formatter(
        '%(asctime)s - %(name)s - %(levelname)s - %(message)s',
        datefmt='%Y-%m-%d %H:%M:%S'
    )
    
    fh.setFormatter(formatter)
    ch.setFormatter(formatter)
    
    logger.addHandler(fh)
    logger.addHandler(ch)
    
    return logger


# Create global logger instance
logger = setup_logger()
```

### 4.4 UtwÃ³rz `src/file_monitor.py`

**New File** â†’ `src/file_monitor.py`

```python
"""FSEvents monitor for detecting recorder mount/unmount."""

import threading
import time
from typing import Callable

from fsevents import Observer, Stream

from src.logger import logger
from src.config import config


class FileMonitor:
    """
    Monitor /Volumes for recorder connection events.
    
    Uses macOS FSEvents for efficient file system monitoring.
    """
    
    def __init__(self, callback: Callable[[], None]) -> None:
        """
        Initialize file monitor.
        
        Args:
            callback: Function to call when recorder is detected
        """
        self.callback = callback
        self.observer: Observer | None = None
        self.is_monitoring = False
    
    def start(self) -> None:
        """Start monitoring /Volumes for mount events."""
        self.observer = Observer()
        
        def on_change(event):
            """Callback for FSEvents."""
            for path in event.paths:
                if any(name in path for name in config.RECORDER_NAMES):
                    logger.info(f"ğŸ“¢ Detected change in {path}")
                    # Wait for system to complete mount
                    time.sleep(config.MOUNT_MONITOR_DELAY)
                    self.callback()
        
        stream = Stream(on_change, "/Volumes", recursive=False)
        self.observer.schedule(stream)
        
        logger.info("âœ“ Mount monitor started (watching /Volumes)")
        self.is_monitoring = True
        self.observer.start()
    
    def stop(self) -> None:
        """Stop monitoring."""
        if self.observer:
            self.observer.stop()
            self.observer.join()
            self.is_monitoring = False
            logger.info("âœ“ Mount monitor stopped")
```

### 4.5 UtwÃ³rz `src/transcriber.py`

**New File** â†’ `src/transcriber.py`

```python
"""Main transcription engine."""

import json
import subprocess
import time
from datetime import datetime, timedelta
from pathlib import Path
from typing import Set

from src.config import config
from src.logger import logger


class Transcriber:
    """Main transcription engine."""
    
    def __init__(self) -> None:
        """Initialize transcriber."""
        self.transcription_in_progress: dict[str, bool] = {}
        self.macwhisper_path = self._find_macwhisper()
        self.recorder_monitoring = False
    
    def _find_macwhisper(self) -> str | None:
        """
        Find MacWhisper binary.
        
        Returns:
            Path to MacWhisper or None if not found
        """
        for path in config.MACWHISPER_PATHS:
            if Path(path).exists():
                logger.info(f"âœ“ Found MacWhisper at: {path}")
                return path
        
        logger.warning("âš  MacWhisper not found at expected paths")
        return None
    
    def find_recorder(self) -> Path | None:
        """
        Find connected recorder.
        
        Returns:
            Path to recorder mount point or None
        """
        volumes_path = Path("/Volumes")
        if not volumes_path.exists():
            return None
        
        for name in config.RECORDER_NAMES:
            recorder = volumes_path / name
            if recorder.exists() and recorder.is_dir():
                logger.info(f"âœ“ Recorder found: {recorder}")
                return recorder
        
        return None
    
    def get_last_sync_time(self) -> datetime:
        """
        Get time of last synchronization.
        
        Returns:
            datetime of last sync or 1 week ago if no state file
        """
        if config.STATE_FILE.exists():
            try:
                with open(config.STATE_FILE, 'r') as f:
                    data = json.load(f)
                    last_sync_str = data.get("last_sync")
                    if last_sync_str:
                        return datetime.fromisoformat(last_sync_str)
            except Exception as e:
                logger.error(f"Error reading state file: {e}")
        
        # Default: 1 week ago
        return datetime.now() - timedelta(days=7)
    
    def save_sync_time(self) -> None:
        """Save current time as last sync time."""
        try:
            config.STATE_FILE.parent.mkdir(parents=True, exist_ok=True)
            with open(config.STATE_FILE, 'w') as f:
                json.dump({"last_sync": datetime.now().isoformat()}, f)
        except Exception as e:
            logger.error(f"Error saving state file: {e}")
    
    def _get_transcribed_files(self) -> Set[str]:
        """
        Get set of already transcribed files.
        
        Returns:
            Set of file stems (names without extension)
        """
        transcribed = set()
        if config.TRANSCRIBE_DIR.exists():
            for txt_file in config.TRANSCRIBE_DIR.glob("*.txt"):
                transcribed.add(txt_file.stem)
        return transcribed
    
    def find_audio_files(self, recorder_path: Path, since: datetime) -> list[Path]:
        """
        Find new audio files modified after given time.
        
        Args:
            recorder_path: Path to recorder mount point
            since: Only find files modified after this time
            
        Returns:
            List of audio file paths, sorted by modification time
        """
        audio_extensions = {".mp3", ".wav", ".m4a", ".wma"}
        new_files = []
        
        try:
            for audio_file in recorder_path.rglob("*"):
                if audio_file.suffix.lower() in audio_extensions:
                    try:
                        mtime = datetime.fromtimestamp(audio_file.stat().st_mtime)
                        if mtime > since:
                            new_files.append(audio_file)
                    except OSError as e:
                        logger.warning(f"Could not access {audio_file}: {e}")
                        continue
        except Exception as e:
            logger.error(f"Error scanning for audio files: {e}")
            return []
        
        return sorted(new_files, key=lambda x: x.stat().st_mtime)
    
    def transcribe_file(self, audio_file: Path) -> bool:
        """
        Transcribe a single audio file.
        
        Args:
            audio_file: Path to audio file
            
        Returns:
            True if transcription succeeded or already exists, False otherwise
        """
        if not self.macwhisper_path:
            logger.error("MacWhisper not available")
            return False
        
        output_file = config.TRANSCRIBE_DIR / f"{audio_file.stem}.txt"
        file_id = audio_file.stem
        
        # Check if already transcribing
        if file_id in self.transcription_in_progress:
            logger.info(f"â³ Already transcribing: {audio_file.name}")
            return False
        
        # Check if already transcribed
        if output_file.exists():
            logger.info(f"âœ“ Already transcribed: {audio_file.name}")
            return True
        
        logger.info(f"ğŸ™ï¸  Starting transcription: {audio_file.name}")
        self.transcription_in_progress[file_id] = True
        
        try:
            config.TRANSCRIBE_DIR.mkdir(parents=True, exist_ok=True)
            
            result = subprocess.run(
                [self.macwhisper_path, str(audio_file), "-o", str(output_file)],
                capture_output=True,
                timeout=config.TRANSCRIPTION_TIMEOUT,
                text=True
            )
            
            if result.returncode == 0:
                logger.info(f"âœ“ Transcription complete: {audio_file.name}")
                return True
            else:
                logger.error(f"âœ— Transcription failed: {audio_file.name}")
                logger.error(f"  Error: {result.stderr}")
                return False
        
        except subprocess.TimeoutExpired:
            logger.error(f"âœ— Transcription timeout: {audio_file.name}")
            return False
        except Exception as e:
            logger.error(f"âœ— Unexpected error: {audio_file.name}: {e}")
            return False
        finally:
            self.transcription_in_progress.pop(file_id, None)
    
    def process_recorder(self) -> None:
        """Main processing workflow when recorder is connected."""
        logger.info("=" * 60)
        logger.info("ğŸ” Checking for Olympus recorder...")
        
        # Find recorder
        recorder = self.find_recorder()
        if not recorder:
            logger.info("âŒ Recorder not found")
            self.recorder_monitoring = False
            return
        
        logger.info("âœ“ Recorder detected")
        self.recorder_monitoring = True
        
        # Get last sync time
        last_sync = self.get_last_sync_time()
        logger.info(f"ğŸ“… Looking for files modified after: {last_sync}")
        
        # Find new audio files
        new_files = self.find_audio_files(recorder, last_sync)
        logger.info(f"ğŸ“ Found {len(new_files)} audio files to process")
        
        # Transcribe each file
        if new_files:
            for audio_file in new_files:
                self.transcribe_file(audio_file)
                time.sleep(1)  # Small delay between files
        else:
            logger.info("â„¹ï¸  No new files found")
        
        # Save sync time
        self.save_sync_time()
        logger.info("âœ“ Sync complete")
        logger.info("=" * 60)
```

### 4.6 UtwÃ³rz `src/main.py`

**New File** â†’ `src/main.py`

```python
"""Main entry point for Olympus Transcriber."""

import sys
import threading
import time
from typing import NoReturn

from src.file_monitor import FileMonitor
from src.logger import logger
from src.transcriber import Transcriber


def setup_periodic_check(transcriber: Transcriber) -> None:
    """
    Setup periodic check as fallback if FSEvents fails.
    
    Checks for recorder every N seconds.
    
    Args:
        transcriber: Transcriber instance
    """
    def periodic_check() -> NoReturn:
        logger.info(f"ğŸ“ Starting periodic checker (every {30}s)...")
        while True:
            try:
                time.sleep(30)
                if transcriber.find_recorder():
                    if not transcriber.recorder_monitoring:
                        transcriber.process_recorder()
            except Exception as e:
                logger.error(f"Error in periodic check: {e}")
    
    checker_thread = threading.Thread(target=periodic_check, daemon=True)
    checker_thread.start()


def main() -> None:
    """Main entry point."""
    logger.info("=" * 60)
    logger.info("ğŸš€ Olympus Transcriber started")
    logger.info("=" * 60)
    logger.info(f"ğŸ“‚ Output: {Transcriber().find_recorder()}")
    logger.info(f"ğŸ™ï¸  State: {Transcriber().get_last_sync_time()}")
    
    # Create transcriber and monitor
    transcriber = Transcriber()
    monitor = FileMonitor(callback=transcriber.process_recorder)
    
    try:
        # Start FSEvents monitor (primary)
        monitor.start()
        
        # Start periodic check (fallback)
        setup_periodic_check(transcriber)
        
        logger.info("âœ“ All monitors running")
        logger.info("â³ Waiting for recorder connection...")
        
        # Keep main thread alive
        while True:
            time.sleep(1)
    
    except KeyboardInterrupt:
        logger.info("\nâ¹ Shutting down gracefully...")
        monitor.stop()
        sys.exit(0)
    except Exception as e:
        logger.error(f"Fatal error: {e}", exc_info=True)
        sys.exit(1)


if __name__ == "__main__":
    main()
```

---

## CZÄ˜ÅšÄ† 5: Debugowanie w Cursor (3 minuty)

### 5.1 UtwÃ³rz `.vscode/launch.json`

**New File** â†’ `.vscode/launch.json`

```json
{
    "version": "0.2.0",
    "configurations": [
        {
            "name": "Debug Main",
            "type": "debugpy",
            "request": "launch",
            "program": "${workspaceFolder}/src/main.py",
            "console": "integratedTerminal",
            "justMyCode": true,
            "cwd": "${workspaceFolder}"
        }
    ]
}
```

### 5.2 UtwÃ³rz `.cursor/rules/python-rules.mdc`

**New File** â†’ `.cursor/rules/python-rules.mdc`

```markdown
---
title: "Olympus Transcriber Python Rules"
description: "Python coding standards for this project"
globs: "src/**/*.py"
alwaysApply: true
---

# Coding Standards

- Use type hints for all function parameters and returns
- Follow PEP 8 strictly (max 88 chars per line)
- Write docstrings for all functions (Google style)
- All functions should be testable
- Use logging instead of print()
- Never use global variables (use classes)

# Project Rules

- Import order: stdlib â†’ third-party â†’ local
- Use `from src.logger import logger` for logging
- All file I/O must handle exceptions
- All subprocess calls must have timeout
- Never hardcode paths - use `from src.config import config`
```

---

## CZÄ˜ÅšÄ† 6: Testowanie Lokalne (5 minut)

### 6.1 Uruchom AplikacjÄ™

W Terminal (Ctrl + `):

```bash
source venv/bin/activate
python src/main.py
```

**âœ“ Oczekiwany output:**
```
============================================================
ğŸš€ Olympus Transcriber started
============================================================
ğŸ“‚ Output: None
ğŸ™ï¸  State: 2025-11-12 10:35:00.123456
âœ“ All monitors running
â³ Waiting for recorder connection...
```

### 6.2 Uruchom Drugi Terminal

Ctrl + `  (drugi terminal)

```bash
tail -f ~/Library/Logs/olympus_transcriber.log
```

### 6.3 Test - PodÅ‚Ä…cz Recorder

1. PodÅ‚Ä…cz Olympus LS-P1
2. Obserwuj logi - powinny pokazaÄ‡:
   ```
   ğŸ“¢ Detected change in /Volumes/LS-P1
   ğŸ” Checking for Olympus recorder...
   âœ“ Recorder detected
   ```

### 6.4 Stop

W Terminal z aplikacjÄ…: **Ctrl + C**

---

## CZÄ˜ÅšÄ† 7: Deployment na LaunchAgent (2 minuty)

### 7.1 UtwÃ³rz `setup.sh`

**New File** â†’ `setup.sh`

```bash
#!/bin/bash

set -e

echo "ğŸš€ Olympus Transcriber - Setup"

# Create directories
mkdir -p ~/Library/LaunchAgents
mkdir -p ~/Documents/Transcriptions

# Create LaunchAgent
cat > ~/Library/LaunchAgents/com.user.olympus-transcriber.plist << 'EOF'
<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE plist PUBLIC "-//Apple//DTD PLIST 1.0//EN" "http://www.apple.com/DTDs/PropertyList-1.0.dtd">
<plist version="1.0">
<dict>
    <key>Label</key>
    <string>com.user.olympus-transcriber</string>
    
    <key>ProgramArguments</key>
    <array>
        <string>/usr/bin/python3</string>
        <string>SCRIPT_PATH</string>
    </array>
    
    <key>RunAtLoad</key>
    <true/>
    
    <key>KeepAlive</key>
    <true/>
    
    <key>StandardOutPath</key>
    <string>/tmp/olympus-transcriber-out.log</string>
    
    <key>StandardErrorPath</key>
    <string>/tmp/olympus-transcriber-err.log</string>
</dict>
</plist>
EOF

# Replace SCRIPT_PATH
sed -i '' "s|SCRIPT_PATH|$(pwd)/src/main.py|g" ~/Library/LaunchAgents/com.user.olympus-transcriber.plist

# Load LaunchAgent
launchctl load ~/Library/LaunchAgents/com.user.olympus-transcriber.plist

echo "âœ“ Setup complete!"
echo ""
echo "Service status:"
launchctl list | grep olympus
```

### 7.2 Uruchom Setup

```bash
chmod +x setup.sh
bash setup.sh
```

### 7.3 Weryfikacja

```bash
# Check if running
launchctl list | grep olympus

# Watch logs
tail -f ~/Library/Logs/olympus_transcriber.log
```

---

## Dodatkowe Pliki Konfiguracyjne

### README.md

**New File** â†’ `README.md`

```markdown
# Olympus Transcriber

Automatic transcription system for Olympus LS-P1 recorder on macOS.

**Features:**
- ğŸ™ï¸ Auto-detects recorder connection via FSEvents
- ğŸ“ Automatically transcribes new audio files with MacWhisper
- ğŸ“Š Tracks transcription history to avoid duplicates
- ğŸ”„ Runs as LaunchAgent (silent background daemon)
- ğŸ Written in Python for easy extensibility

## Quick Start

### 1. Clone and Setup

```bash
git clone <your-repo>
cd olympus-transcriber

# Create virtual environment
python3 -m venv venv
source venv/bin/activate

# Install dependencies
pip install -r requirements.txt
```

### 2. Test Locally

```bash
# Run the transcriber
python src/main.py

# In another terminal, plug in your Olympus LS-P1 recorder
# You should see logs appearing
```

### 3. Deploy as LaunchAgent

```bash
bash setup.sh
```

## Configuration

Edit `src/config.py` to customize paths and timeouts.

### Multi-Computer Setup: TRANSCRIBE_DIR

When installing the application on multiple Macs with different usernames, configure `OLYMPUS_TRANSCRIBE_DIR` to point to the same synchronized Obsidian vault directory on all computers. This prevents duplicate transcriptions.

**On each computer:**

1. **Determine your Obsidian vault transcription directory path**
   
   Example:
   ```
   /Users/your_username/Library/Mobile Documents/iCloud~md~obsidian/Documents/Obsidian/11-Transcripts
   ```

2. **Set environment variable**

   **Option A: Using `.env` file** (for development/testing)
   
   Create `.env` in project root:
   ```bash
   echo 'OLYMPUS_TRANSCRIBE_DIR="/Users/your_username/Library/Mobile Documents/iCloud~md~obsidian/Documents/Obsidian/11-Transcripts"' >> .env
   ```

   **Option B: Using shell profile** (for production/LaunchAgent)
   
   Add to `~/.zshrc`:
   ```bash
   echo 'export OLYMPUS_TRANSCRIBE_DIR="/Users/your_username/Library/Mobile Documents/iCloud~md~obsidian/Documents/Obsidian/11-Transcripts"' >> ~/.zshrc
   source ~/.zshrc
   ```

3. **Verify configuration**
   
   Start the application and check logs:
   ```bash
   python src/main.py
   ```
   
   Look for:
   ```
   âœ“ TRANSCRIBE_DIR set from OLYMPUS_TRANSCRIBE_DIR: /path/to/vault
   ```

**Important:**
- All computers must use the **exact same directory path** (same vault folder)
- The application automatically prevents duplicates by checking for existing markdown files with matching `source: <audio_file>` in YAML frontmatter
- If you see a warning about non-synced location, ensure you're using a synchronized vault (iCloud/Obsidian)

## Logs

- Main: `~/Library/Logs/olympus_transcriber.log`
- LaunchAgent out: `/tmp/olympus-transcriber-out.log`
- LaunchAgent err: `/tmp/olympus-transcriber-err.log`
```

---

## Troubleshooting

### Setup Fails

```
âŒ command not found: python3
   â†’ Zainstaluj Python ze strony python.org

âŒ No such file or directory: venv
   â†’ Uruchom: python3 -m venv venv

âŒ ModuleNotFoundError
   â†’ Aktywuj venv, uruchom: pip install -r requirements.txt
```

### Runtime Fails

```
âŒ MacWhisper not found
   â†’ Zainstaluj MacWhisper, sprawdÅº path w config.py

âŒ Recorder not detected
   â†’ SprawdÅº: ls /Volumes/
   â†’ Powinna byÄ‡ /Volumes/LS-P1

âŒ Permission denied
   â†’ Uruchom: chmod +x setup.sh
```

### LaunchAgent Issues

```
âŒ Service not starting
   â†’ launchctl load ~/Library/LaunchAgents/com.user.olympus-transcriber.plist

âŒ Service crashes
   â†’ tail -f /tmp/olympus-transcriber-err.log

âŒ State not persisting
   â†’ SprawdÅº permissions na ~/.olympus_transcriber_state.json
```

---

## Success Criteria âœ…

System jest **READY** gdy:

- âœ… `python src/main.py` uruchamia siÄ™ bez bÅ‚Ä™dÃ³w
- âœ… LaunchAgent `com.user.olympus-transcriber` jest zaÅ‚adowany
- âœ… `tail ~/Library/Logs/olympus_transcriber.log` pokazuje logi
- âœ… Po podÅ‚Ä…czeniu recordera pojawiajÄ… siÄ™ logi detektujÄ…ce zmianÄ™
- âœ… Transkrypcje pojawiajÄ… siÄ™ w `~/Documents/Transcriptions/`
- âœ… Stan persists w `~/.olympus_transcriber_state.json`

---

## Useful Commands

```bash
# Uruchom lokalnie
source venv/bin/activate
python src/main.py

# Uruchom testy
pytest tests/ -v

# Format kodu
black src/

# Type checking
mypy src/

# Linter
flake8 src/

# Logi applicacji
tail -f ~/Library/Logs/olympus_transcriber.log

# Logi LaunchAgent
tail -f /tmp/olympus-transcriber-out.log
tail -f /tmp/olympus-transcriber-err.log

# LaunchAgent Management
launchctl load ~/Library/LaunchAgents/com.user.olympus-transcriber.plist
launchctl unload ~/Library/LaunchAgents/com.user.olympus-transcriber.plist
launchctl list | grep olympus
```

---

## File Locations

| Co | Gdzie |
|---|---|
| **Source Code** | `~/Projects/olympus-transcriber/src/` |
| **State (sync time)** | `~/.olympus_transcriber_state.json` |
| **Transcriptions** | `~/Documents/Transcriptions/` |
| **Logi (dev)** | `~/Library/Logs/olympus_transcriber.log` |
| **Logi (production)** | `/tmp/olympus-transcriber-*.log` |
| **LaunchAgent Config** | `~/Library/LaunchAgents/com.user.olympus-transcriber.plist` |

---

**Good luck! Powodzenia! ğŸš€**
